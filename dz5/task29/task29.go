package main

import (
	"fmt"
	"sort"
)

//29. Кафе
//Ограничение времени	1 секунда
//Ограничение памяти	64Mb
//Ввод	стандартный ввод или input.txt
//Вывод	стандартный вывод или output.txt
//Около Петиного университета недавно открылось новое кафе, в котором действует следующая система скидок: при каждой покупке более чем на 100 рублей покупатель получает купон, дающий право на один бесплатный обед (при покупке на сумму 100 рублей и меньше такой купон покупатель не получает).
//
//Однажды Пете на глаза попался прейскурант на ближайшие N дней. Внимательно его изучив, он решил, что будет обедать в этом кафе все N дней, причем каждый день он будет покупать в кафе ровно один обед. Однако стипендия у Пети небольшая, и поэтому он хочет по максимуму использовать предоставляемую систему скидок так, чтобы его суммарные затраты были минимальны. Требуется найти минимально возможную суммарную стоимость обедов и номера дней, в которые Пете следует воспользоваться купонами.
//
//Формат ввода
//В первой строке входного файла записано целое число N (0 ≤ N ≤ 100). В каждой из последующих N строк записано одно целое число, обозначающее стоимость обеда в рублях на соответствующий день. Стоимость — неотрицательное целое число, не превосходящее 300.
//
//Формат вывода
//В первой строке выдайте минимальную возможную суммарную стоимость обедов. Во второй строке выдайте два числа K1 и K2 — количество купонов, которые останутся неиспользованными у Пети после этих N дней и количество использованных им купонов соответственно.
//
//В последующих K2 строках выдайте в возрастающем порядке номера дней, когда Пете следует воспользоваться купонами. Если существует несколько решений с минимальной суммарной стоимостью, то выдайте то из них, в котором значение K1 максимально (на случай, если Петя когда-нибудь ещё решит заглянуть в это кафе). Если таких решений несколько, выведите любое из них.

func main() {
	var n int
	fmt.Scan(&n)

	costs := make([]int, n+1)
	for i := 1; i <= n; i++ {
		fmt.Scan(&costs[i])
	}

	dp := makeMatrix(n, n)
	fmt.Println(f(dp, costs))
}

func f(dp [][]int, costs []int) (minCost, resCounpons, couponCounter int, usedDays []int) {
	dp[0][1] = costs[1]
	for i := 0; i < len(dp)-1; i++ {
		for j := 1; j < len(dp[0])-1; j++ {
			if dp[i][j] == 30001 {
				continue
			}
			if i > 0 {
				//used coupon
				dp[i-1][j+1] = dp[i][j]
				usedDays = append(usedDays, j+1)
			}
			if costs[j] > 100 {
				//got a coupon
				dp[i+1][j+1] = dp[i][j] + costs[j+1]
				i++
				couponCounter++
			} else {
				//just spent money
				dp[i][j+1] = dp[i][j] + costs[j+1]
			}
		}
		//print matrix
		for i := 0; i < len(dp); i++ {
			fmt.Println(dp[i])
		}
		fmt.Println()
	}
	var results []int
	for i := 0; i < len(dp); i++ {
		results = append(results, dp[i][len(dp[i])-1])
	}
	sort.Ints(results)
	minCost = results[0]
	for i := 0; i < len(dp); i++ {
		if dp[i][len(dp[i])-1] == minCost {
			resCounpons = i
		}
	}
	return
}

func makeMatrix(n, m int) [][]int {
	m++
	matrix := make([][]int, n)
	for i := 0; i < n; i++ {
		matrix[i] = make([]int, m)
	}
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			matrix[i][j] = 30001
		}
	}
	return matrix
}
