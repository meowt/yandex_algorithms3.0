package main

import (
	"fmt"
	"os"
)

//18. Дек с защитой от ошибок
//Ограничение времени	1 секунда
//Ограничение памяти	64Mb
//Ввод	стандартный ввод или input.txt
//Вывод	стандартный вывод или output.txt
//Научитесь пользоваться стандартной структурой данных deque для целых чисел.  Напишите программу, содержащую описание дека и моделирующую работу дека, реализовав все указанные здесь методы. Программа считывает последовательность команд и в зависимости от команды выполняет ту или иную операцию. После выполнения каждой команды программа должна вывести одну строчку.
//
//Возможные команды для программы:
//
//push_front n
//Добавить (положить) в начало дека новый элемент. Программа должна вывести ok.
//
//push_back n
//Добавить (положить) в конец дека новый элемент. Программа должна вывести ok.
//
//pop_front
//Извлечь из дека первый элемент. Программа должна вывести его значение.
//
//pop_back
//Извлечь из дека последний элемент. Программа должна вывести его значение.
//
//front
//Узнать значение первого элемента (не удаляя его). Программа должна вывести его значение.
//
//back
//Узнать значение последнего элемента (не удаляя его). Программа должна вывести его значение.
//
//size
//Вывести количество элементов в деке.
//
//clear
//Очистить дек (удалить из него все элементы) и вывести ok.
//
//exit
//Программа должна вывести bye и завершить работу.
//
//Гарантируется, что количество элементов в деке в любой момент не превосходит 100. Перед исполнением операций pop_front, pop_back, front, back программа должна проверять, содержится ли в деке хотя бы один элемент. Если во входных данных встречается операция pop_front, pop_back, front, back, и при этом дек пуст, то программа должна вместо числового значения вывести строку error.
//
//Формат ввода
//Вводятся команды управления деком, по одной на строке.
//
//Формат вывода
//Требуется вывести протокол работы дека, по одному сообщению на строке

func main() {
	var command string
	var deq []int

	for {
		fmt.Scan(&command)

		switch command {
		case "push_front":
			var n int
			fmt.Scan(&n)
			tempSlc := []int{n}
			deq = append(tempSlc, deq...)
			fmt.Println("ok")

		case "push_back":
			var n int
			fmt.Scan(&n)
			deq = append(deq, n)
			fmt.Println("ok")

		case "pop_front":
			if len(deq) != 0 {
				fmt.Println(deq[0])
				deq = deq[1:]
			} else {
				fmt.Println("error")
			}

		case "pop_back":
			if len(deq) != 0 {
				fmt.Println(deq[len(deq)-1])
				deq = deq[:len(deq)-1]
			} else {
				fmt.Println("error")
			}

		case "front":
			if len(deq) != 0 {
				fmt.Println(deq[0])
			} else {
				fmt.Println("error")
			}

		case "back":
			if len(deq) != 0 {
				fmt.Println(deq[len(deq)-1])
			} else {
				fmt.Println("error")
			}

		case "size":
			fmt.Println(len(deq))

		case "clear":
			deq = []int{}
			fmt.Println("ok")

		case "exit":
			fmt.Println("bye")
			os.Exit(0)
		}
	}
}
